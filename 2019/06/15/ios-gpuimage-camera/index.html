<!DOCTYPE html>




<html class="theme-next mist" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">










<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.0.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="iOS, GPUImage, camera, 相机, 滤镜" />


<meta name="description" content="本文介绍了如何使用 GPUImage 来实现一个简单的相机。具体功能包括拍照、录制视频、多段视频合成、实时美颜、自定义滤镜实现等。">
<meta name="keywords" content="iOS, GPUImage, camera, 相机, 滤镜">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 GPUImage 实现一个简单相机">
<meta property="og:url" content="http://www.lymanli.com/2019/06/15/ios-gpuimage-camera/index.html">
<meta property="og:site_name" content="Lyman&#39;s Blog">
<meta property="og:description" content="本文介绍了如何使用 GPUImage 来实现一个简单的相机。具体功能包括拍照、录制视频、多段视频合成、实时美颜、自定义滤镜实现等。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera.jpg">
<meta property="og:image" content="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera-image-1.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/lmf12/SimpleCam/master/Images/image-1.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/lmf12/SimpleCam/master/Images/image-2.gif">
<meta property="og:updated_time" content="2019-06-17T16:50:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用 GPUImage 实现一个简单相机">
<meta name="twitter:description" content="本文介绍了如何使用 GPUImage 来实现一个简单的相机。具体功能包括拍照、录制视频、多段视频合成、实时美颜、自定义滤镜实现等。">
<meta name="twitter:image" content="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera.jpg">






  <link rel="canonical" href="http://www.lymanli.com/2019/06/15/ios-gpuimage-camera/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>使用 GPUImage 实现一个简单相机 | Lyman's Blog</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129740170-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129740170-1');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lyman's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            首页</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            分类</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            关于</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lymanli.com/2019/06/15/ios-gpuimage-camera/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lyman Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyman's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">使用 GPUImage 实现一个简单相机</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T12:05:46+08:00">2019-06-15</time>
            

            
            
              
                
              
            

            
              
              <span class="post-meta-divider">|</span>
              

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-06-18T00:50:32+08:00">2019-06-18</time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/GPUImage-实操手册/" itemprop="url" rel="index"><span itemprop="name">GPUImage 实操手册</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/06/15/ios-gpuimage-camera/" class="leancloud_visitors" data-flag-title="使用 GPUImage 实现一个简单相机">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera.jpg" alt=""></p>
<p>本文介绍了如何使用 GPUImage 来实现一个简单的相机。具体功能包括拍照、录制视频、多段视频合成、实时美颜、自定义滤镜实现等。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>AVFoundation 是苹果提供的用于处理基于时间的媒体数据的一个框架。我们想要实现一个相机，需要从手机摄像头采集数据，离不开这个框架的支持。GPUImage 对 AVFoundation 做了一些封装，使我们的采集工作变得十分简单。</p>
<p>另外，GPUImage 的核心魅力还在于，它封装了一个链路结构的图像数据处理流程，简称<strong>滤镜链</strong>。滤镜链的结构使得多层滤镜的叠加功能变得很容易实现。</p>
<p>在下面介绍的功能中，有一些和 GPUImage 本身的关系并不大，我们是直接调用 AVFoundation 的 API 来实现的。但是，这些功能也是一个相机应用必不可少的一部分。所以，我们也会简单讲一下每个功能的实现方式和注意事项。</p>
<h1 id="滤镜链简介"><a href="#滤镜链简介" class="headerlink" title="滤镜链简介"></a>滤镜链简介</h1><p>在 GPUImage 中，对图像数据的处理都是通过建立滤镜链来实现的。</p>
<p>这里就涉及到了一个类 <code>GPUImageOutput</code> 和一个协议 <code>GPUImageInput</code> 。对于继承了 <code>GPUImageOutput</code> 的类，可以理解为<strong>具备输出图像数据</strong>的能力；对于实现了 <code>GPUImageInput</code> 协议的类，可以理解为<strong>具备接收图像数据输入</strong>的能力。</p>
<p>顾名思义，滤镜链作为一个链路，具有起点和终点。根据前面的描述，滤镜链的起点应该只继承了 <code>GPUImageOutput</code> 类，滤镜链的终点应该只实现了 <code>GPUImageInput</code> 协议，而对于中间的结点应该同时继承了 <code>GPUImageOutput</code> 类并实现了 <code>GPUImageInput</code> 协议，这样才具备承上启下的作用。</p>
<h2 id="一、滤镜链起点"><a href="#一、滤镜链起点" class="headerlink" title="一、滤镜链起点"></a>一、滤镜链起点</h2><p>在 GPUImage 中，只继承了 <code>GPUImageOutput</code>，而没有实现  <code>GPUImageInput</code> 协议的类有六个，也就是说有六种类型的输入源：</p>
<p><strong>1、GPUImagePicture</strong></p>
<p><code>GPUImagePicture</code> 通过图片来初始化，本质上是先将图片转化为 <code>CGImageRef</code>，然后将 <code>CGImageRef</code> 转化为纹理。</p>
<p><strong>2、GPUImageRawDataInput</strong></p>
<p><code>GPUImageRawDataInput</code> 通过二进制数据初始化，然后将二进制数据转化为纹理，在初始化的时候需要指明数据的格式（<code>GPUPixelFormat</code>）。</p>
<p><strong>3、GPUImageTextureInput</strong></p>
<p><code>GPUImageTextureInput</code> 通过已经存在的纹理来初始化。既然纹理已经存在，在初始化的时候就不会重新去生成，只是将纹理的索引保存下来。</p>
<p><strong>4、GPUImageUIElement</strong></p>
<p><code>GPUImageUIElement</code> 可以通过 <code>UIView</code> 或者 <code>CALayer</code> 来初始化，最后都是调用 <code>CALayer</code> 的 <code>renderInContext:</code> 方法，将当前显示的内容绘制到 CoreGraphics 的上下文中，从而获取图像数据。然后将数据转化为纹理。简单来说就是截屏，截取当前控件的内容。</p>
<p>这个类可以用来实现在视频上添加文字水印的功能。因为在 OpenGL 中不能直接进行文本的绘制，所以如果我们想把一个 <code>UILabel</code> 的内容添加到滤镜链里面去，使用 <code>GPUImageUIElement</code> 来实现是很合适的。</p>
<p><strong>5、GPUImageMovie</strong></p>
<p><code>GPUImageMovie</code> 通过本地的视频来初始化。首先通过 <code>AVAssetReader</code> 来逐帧读取视频，然后将帧数据转化为纹理，具体的流程大概是：<code>AVAssetReaderOutput</code> -&gt; <code>CMSampleBufferRef</code> -&gt; <code>CVImageBufferRef</code> -&gt; <code>CVOpenGLESTextureRef</code> -&gt; <code>Texture</code> 。 </p>
<p><strong>6、GPUImageVideoCamera</strong></p>
<p><code>GPUImageVideoCamera</code> 通过相机参数来初始化，通过<strong>屏幕比例</strong>和<strong>相机位置（前后置）</strong>来初始化相机。这里主要使用 <code>AVCaptureVideoDataOutput</code> 来获取持续的视频流数据输出，在代理方法 <code>captureOutput:didOutputSampleBuffer:fromConnection:</code> 中可以拿到 <code>CMSampleBufferRef</code> ，将其转化为纹理的过程与 <code>GPUImageMovie</code> 类似。</p>
<p>然而，我们在项目中使用的是它的子类 <code>GPUImageStillCamera</code>。 <code>GPUImageStillCamera</code> 在原来的基础上多了一个 <code>AVCaptureStillImageOutput</code>，它是我们实现拍照功能的关键，在 <code>captureStillImageAsynchronouslyFromConnection:completionHandler:</code> 方法的回调中，同样能拿到我们熟悉 <code>CMSampleBufferRef</code>。</p>
<p>简单来说，<strong><code>GPUImageVideoCamera</code> 只能录制视频，<code>GPUImageStillCamera</code> 还可以拍照，</strong>因此我们使用 <code>GPUImageStillCamera</code> 。 </p>
<h2 id="二、滤镜"><a href="#二、滤镜" class="headerlink" title="二、滤镜"></a>二、滤镜</h2><p>滤镜链的关键角色是 <code>GPUImageFilter</code>，它同时继承了 <code>GPUImageOutput</code> 类并实现了 <code>GPUImageInput</code> 协议。<code>GPUImageFilter</code> 实现<strong>承上启下功能</strong>的基础是「渲染到纹理」，这个操作我们在 <a href="http://www.lymanli.com/2019/03/04/ios-opengles-spring/">《使用 iOS OpenGL ES 实现长腿功能》</a> 一文中已经介绍过了，简单来说就是<strong>将结果渲染到纹理而不是屏幕上</strong>。</p>
<p>这样，每一个滤镜都能把输出的纹理作为下一个滤镜的输入，实现多层滤镜效果的叠加。</p>
<h2 id="三、滤镜链终点"><a href="#三、滤镜链终点" class="headerlink" title="三、滤镜链终点"></a>三、滤镜链终点</h2><p>在 GPUImage 中，实现了 <code>GPUImageInput</code> 协议，而没有继承 <code>GPUImageOutput</code> 的类有四个：</p>
<p><strong>1、GPUImageMovieWriter</strong></p>
<p><code>GPUImageMovieWriter</code> 封装了 <code>AVAssetWriter</code>，可以逐帧从帧缓存的渲染结果中读取数据，最后通过 <code>AVAssetWriter</code> 将视频文件保存到指定的路径。</p>
<p><strong>2、GPUImageRawDataOutput</strong></p>
<p><code>GPUImageRawDataOutput</code> 通过 <code>rawBytesForImage</code> 属性，可以获取到当前输入纹理的二进制数据。</p>
<p>假设我们的滤镜链在输入源和终点之间，连接了三个滤镜，而我们需要拿到第二个滤镜渲染后的数据，用来做人脸识别。那我们可以在第二个滤镜后面再添加一个 <code>GPUImageRawDataOutput</code> 作为输出，则可以拿到对应的二进制数据，且不会影响原来的渲染流程。</p>
<p><strong>3、GPUImageTextureOutput</strong></p>
<p>这个类的实现十分简单，提供协议方法 <code>newFrameReadyFromTextureOutput:</code>，在每一帧渲染结束后，将自身返回，通过 <code>texture</code> 属性就可以拿到输入纹理的索引。</p>
<p><strong>4、GPUImageView</strong></p>
<p><code>GPUImageView</code> 继承自 <code>UIView</code>，通过输入的纹理，执行一遍渲染流程。这次的渲染目标不是新的纹理，而是自身的 <code>layer</code> 。</p>
<p>这个类是我们实现相机功能的重要组成部分，我们所有的滤镜效果，都要依靠它来呈现。</p>
<h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="一、拍照"><a href="#一、拍照" class="headerlink" title="一、拍照"></a>一、拍照</h2><p>拍照功能只需调用一个接口就能搞定，在回调方法中可以直接拿到 <code>UIImage</code>。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)takePhotoWtihCompletion:(TakePhotoResult)completion &#123;</span><br><span class="line">    GPUImageFilter *lastFilter = <span class="keyword">self</span>.currentFilterHandler.lastFilter;</span><br><span class="line">    [<span class="keyword">self</span>.camera capturePhotoAsImageProcessedUpToFilter:lastFilter withCompletionHandler:^(<span class="built_in">UIImage</span> *processedImage, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error &amp;&amp; completion) &#123;</span><br><span class="line">            completion(<span class="literal">nil</span>, error);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion(processedImage, <span class="literal">nil</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，相机的预览页面由 <code>GPUImageView</code> 承载，显示的是整个滤镜链作用的结果。而我们的拍照接口，可以传入这个链路上的任意一个滤镜，甚至可以在后面多加一个滤镜，然后拍照接口会返回对应滤镜的渲染结果。即<strong>我们的拍照结果不一定要和我们的预览一致</strong>。</p>
<p>示意图如下：</p>
<p><img src="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera-image-1.jpg" alt=""></p>
<h2 id="二、录制视频"><a href="#二、录制视频" class="headerlink" title="二、录制视频"></a>二、录制视频</h2><h3 id="1、单段录制"><a href="#1、单段录制" class="headerlink" title="1、单段录制"></a>1、单段录制</h3><p>录制视频首先要创建一个 <code>GPUImageMovieWriter</code> 作为链路的输出，与上面的拍照接口类似，这里录制的视频不一定和我们的预览一样。</p>
<p>整个过程比较简单，当我们调用停止录制的接口并回调之后，视频就被保存到我们指定的路径了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupMovieWriter &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *videoPath = [SCFileHelper randomFilePathInTmpWithSuffix:<span class="string">@".m4v"</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *videoURL = [<span class="built_in">NSURL</span> fileURLWithPath:videoPath];</span><br><span class="line">    <span class="built_in">CGSize</span> videoSize = <span class="keyword">self</span>.videoSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.movieWriter = [[GPUImageMovieWriter alloc] initWithMovieURL:videoURL</span><br><span class="line">                                                                size:videoSize];</span><br><span class="line">    </span><br><span class="line">    GPUImageFilter *lastFilter = <span class="keyword">self</span>.currentFilterHandler.lastFilter;</span><br><span class="line">    [lastFilter addTarget:<span class="keyword">self</span>.movieWriter];</span><br><span class="line">    <span class="keyword">self</span>.camera.audioEncodingTarget = <span class="keyword">self</span>.movieWriter;</span><br><span class="line">    <span class="keyword">self</span>.movieWriter.shouldPassthroughAudio = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.currentTmpVideoPath = videoPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)recordVideo &#123;</span><br><span class="line">    [<span class="keyword">self</span> setupMovieWriter];</span><br><span class="line">    [<span class="keyword">self</span>.movieWriter startRecording];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stopRecordVideoWithCompletion:(RecordVideoResult)completion &#123;</span><br><span class="line">    @weakify(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span>.movieWriter finishRecordingWithCompletionHandler:^&#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        [<span class="keyword">self</span> removeMovieWriter];</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion(<span class="keyword">self</span>.currentTmpVideoPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、多段录制"><a href="#2、多段录制" class="headerlink" title="2、多段录制"></a>2、多段录制</h3><p>在 <code>GPUImage</code> 中并没有提供多段录制的功能，需要我们自己去实现。</p>
<p>首先，我们要重复单段视频的录制过程，这样我们就有了多段视频的文件路径。然后主要实现两个功能，一个是 <code>AVPlayer</code> 的多段视频循环播放；另一个是通过 <code>AVComposition</code> 来合并多段视频，并用 <code>AVAssetExportSession</code> 来导出新的视频。</p>
<p>整个过程逻辑并不复杂，出于篇幅的考虑，代码就不贴了，请到项目中查看。</p>
<h2 id="三、保存"><a href="#三、保存" class="headerlink" title="三、保存"></a>三、保存</h2><p>在拍照或者录视频结束后，通过 <code>PhotoKit</code> 保存到相册里。</p>
<h3 id="1、保存图片"><a href="#1、保存图片" class="headerlink" title="1、保存图片"></a>1、保存图片</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)writeImageToSavedPhotosAlbum:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                          completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> success))completion &#123;</span><br><span class="line">    [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123;</span><br><span class="line">        [PHAssetChangeRequest creationRequestForAssetFromImage:image];</span><br><span class="line">    &#125; completionHandler:^(<span class="built_in">BOOL</span> success, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion(success);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、保存视频"><a href="#2、保存视频" class="headerlink" title="2、保存视频"></a>2、保存视频</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saveVideo:(<span class="built_in">NSString</span> *)path completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> success))completion &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:path];</span><br><span class="line">    [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123;</span><br><span class="line">        [PHAssetChangeRequest creationRequestForAssetFromVideoAtFileURL:url];</span><br><span class="line">    &#125; completionHandler:^(<span class="built_in">BOOL</span> success, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">                completion(success);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、闪光灯"><a href="#四、闪光灯" class="headerlink" title="四、闪光灯"></a>四、闪光灯</h2><p>系统的闪光灯类型通过 <code>AVCaptureDevice</code> 的 <code>flashMode</code> 属性来控制，其实只有三种，分别是：</p>
<ul>
<li><strong>AVCaptureFlashModeOff</strong> 关闭</li>
<li><strong>AVCaptureFlashModeOn</strong> 开启（在拍照的时候会闪一下）</li>
<li><strong>AVCaptureFlashModeAuto</strong> 自动（系统会自动判断当前的环境是否需要闪光灯）</li>
</ul>
<p>但是市面上的相机应用，一般还有一种<strong>常亮</strong>类型，这种类型在夜间的时候会比较适用。这个功能需要通过 <code>torchMode</code> 属性来实现，它其实是指手电筒。</p>
<p>我们对这个两个属性做一下封装，允许这四种类型来回切换，下面是根据封装的类型来同步系统类型的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)syncFlashState &#123;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="keyword">self</span>.camera.inputCamera;</span><br><span class="line">    <span class="keyword">if</span> (![device hasFlash] || <span class="keyword">self</span>.camera.cameraPosition == <span class="built_in">AVCaptureDevicePositionFront</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> closeFlashIfNeed];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [device lockForConfiguration:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.flashMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> SCCameraFlashModeOff:</span><br><span class="line">            device.torchMode = <span class="built_in">AVCaptureTorchModeOff</span>;</span><br><span class="line">            device.flashMode = <span class="built_in">AVCaptureFlashModeOff</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCCameraFlashModeOn:</span><br><span class="line">            device.torchMode = <span class="built_in">AVCaptureTorchModeOff</span>;</span><br><span class="line">            device.flashMode = <span class="built_in">AVCaptureFlashModeOn</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCCameraFlashModeAuto:</span><br><span class="line">            device.torchMode = <span class="built_in">AVCaptureTorchModeOff</span>;</span><br><span class="line">            device.flashMode = <span class="built_in">AVCaptureFlashModeAuto</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCCameraFlashModeTorch:</span><br><span class="line">            device.torchMode = <span class="built_in">AVCaptureTorchModeOn</span>;</span><br><span class="line">            device.flashMode = <span class="built_in">AVCaptureFlashModeOff</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [device unlockForConfiguration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、画幅比例"><a href="#五、画幅比例" class="headerlink" title="五、画幅比例"></a>五、画幅比例</h2><p>相机的比例通过设置 <code>AVCaptureSession</code> 的  <code>sessionPreset</code> 属性来实现。这个属性并不只意味着比例，也意味着分辨率。</p>
<p>由于不是所有的设备都支持高分辨率，所以这里只使用 <code>AVCaptureSessionPreset640x480</code> 和 <code>AVCaptureSessionPreset1280x720</code> 这两个分辨率，分别用来作为 <code>3:4</code> 和 <code>9:16</code> 的输出。</p>
<p>市面上的相机除了上面的两个比例外，一般还支持 <code>1:1</code> 和 <code>Full</code> （iPhoneX 系列的全屏）比例，但是系统并没有提供对应比例的 <code>AVCaptureSessionPreset</code> 。</p>
<p>这里可以通过 <code>GPUImageCropFilter</code> 来实现，这是 GPUImage 的一个内置滤镜，可以对输入的纹理进行裁剪。使用时通过 <code>cropRegion</code> 属性来传入一个归一化的裁剪区域。</p>
<p>切换比例的关键代码如下： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setRatio:(SCCameraRatio)ratio &#123;</span><br><span class="line">    _ratio = ratio;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ratio == SCCameraRatio1v1) &#123;</span><br><span class="line">        <span class="keyword">self</span>.camera.captureSessionPreset = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> space = (<span class="number">4</span> - <span class="number">3</span>) / <span class="number">4.0</span>; <span class="comment">// 竖直方向应该裁剪掉的空间</span></span><br><span class="line">        rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, space / <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> - space);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ratio == SCCameraRatio4v3) &#123;</span><br><span class="line">        <span class="keyword">self</span>.camera.captureSessionPreset = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ratio == SCCameraRatio16v9) &#123;</span><br><span class="line">        <span class="keyword">self</span>.camera.captureSessionPreset = <span class="built_in">AVCaptureSessionPreset1280x720</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ratio == SCCameraRatioFull) &#123;</span><br><span class="line">        <span class="keyword">self</span>.camera.captureSessionPreset = <span class="built_in">AVCaptureSessionPreset1280x720</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> currentRatio = SCREEN_HEIGHT / SCREEN_WIDTH;</span><br><span class="line">        <span class="keyword">if</span> (currentRatio &gt; <span class="number">16.0</span> / <span class="number">9.0</span>) &#123; <span class="comment">// 需要在水平方向裁剪</span></span><br><span class="line">            <span class="built_in">CGFloat</span> resultWidth = <span class="number">16.0</span> / currentRatio;</span><br><span class="line">            <span class="built_in">CGFloat</span> space = (<span class="number">9.0</span> - resultWidth) / <span class="number">9.0</span>;</span><br><span class="line">            rect = <span class="built_in">CGRectMake</span>(space / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> - space, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 需要在竖直方向裁剪</span></span><br><span class="line">            <span class="built_in">CGFloat</span> resultHeight = <span class="number">9.0</span> * currentRatio;</span><br><span class="line">            <span class="built_in">CGFloat</span> space = (<span class="number">16.0</span> - resultHeight) / <span class="number">16.0</span>;</span><br><span class="line">            rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, space / <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> - space);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.currentFilterHandler setCropRect:rect];</span><br><span class="line">    <span class="keyword">self</span>.videoSize = [<span class="keyword">self</span> videoSizeWithRatio:ratio];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、前后置切换"><a href="#六、前后置切换" class="headerlink" title="六、前后置切换"></a>六、前后置切换</h2><p>通过调用 <code>GPUImageVideoCamera</code> 的 <code>rotateCamera</code> 方法来实现。</p>
<p>另外，由于前置摄像头不支持闪光灯，如果在前置的时候去切换闪光灯，只能修改我们封装的类型。所以在切换到后置的时候，需要去同步一下系统的闪光灯类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)rotateCamera &#123;</span><br><span class="line">    [<span class="keyword">self</span>.camera rotateCamera];</span><br><span class="line">    <span class="comment">// 切换摄像头，同步一下闪光灯</span></span><br><span class="line">    [<span class="keyword">self</span> syncFlashState];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、对焦"><a href="#七、对焦" class="headerlink" title="七、对焦"></a>七、对焦</h2><p><code>AVCaptureDevice</code> 的 <code>focusMode</code> 用来设置聚焦模式，<code>focusPointOfInterest</code> 用来设置聚焦点；<code>exposureMode</code> 用来设置曝光模式，<code>exposurePointOfInterest</code> 用来设置曝光点。</p>
<p><strong>前置摄像头只支持设置曝光，后置摄像头支持设置曝光和聚焦</strong>，所以在设置之前要先判断是否支持。</p>
<p>需要注意的是，相机默认输出的图像是横向的，图像向右偏转。而前置摄像头又是镜像，所以图像是向左偏转。我们从 <code>UIView</code> 获得的触摸点，要经过相应的转化，才是正确的坐标。关键代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setFocusPoint:(<span class="built_in">CGPoint</span>)focusPoint &#123;</span><br><span class="line">    _focusPoint = focusPoint;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="keyword">self</span>.camera.inputCamera;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 坐标转换</span></span><br><span class="line">    <span class="built_in">CGPoint</span> currentPoint = <span class="built_in">CGPointMake</span>(focusPoint.y / <span class="keyword">self</span>.outputView.bounds.size.height, <span class="number">1</span> - focusPoint.x / <span class="keyword">self</span>.outputView.bounds.size.width);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.camera.cameraPosition == <span class="built_in">AVCaptureDevicePositionFront</span>) &#123;</span><br><span class="line">        currentPoint = <span class="built_in">CGPointMake</span>(currentPoint.x, <span class="number">1</span> - currentPoint.y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [device lockForConfiguration:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([device isFocusPointOfInterestSupported] &amp;&amp;</span><br><span class="line">        [device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeAutoFocus</span>]) &#123;</span><br><span class="line">        [device setFocusPointOfInterest:currentPoint];</span><br><span class="line">        [device setFocusMode:<span class="built_in">AVCaptureFocusModeAutoFocus</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([device isExposurePointOfInterestSupported] &amp;&amp;</span><br><span class="line">        [device isExposureModeSupported:<span class="built_in">AVCaptureExposureModeAutoExpose</span>]) &#123;</span><br><span class="line">        [device setExposurePointOfInterest:currentPoint];</span><br><span class="line">        [device setExposureMode:<span class="built_in">AVCaptureExposureModeAutoExpose</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    [device unlockForConfiguration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八、改变焦距"><a href="#八、改变焦距" class="headerlink" title="八、改变焦距"></a>八、改变焦距</h2><p>改变焦距简单来说就是画面的放大缩小，通过设置 <code>AVCaptureDevice</code> 的 <code>videoZoomFactor</code> 属性实现。</p>
<p>值得注意的是，这个属性有最大值和最小值，设置之前需要做好判断，否则会直接崩溃。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setVideoScale:(<span class="built_in">CGFloat</span>)videoScale &#123;</span><br><span class="line">    _videoScale = videoScale;</span><br><span class="line">    </span><br><span class="line">    videoScale = [<span class="keyword">self</span> availableVideoScaleWithScale:videoScale];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="keyword">self</span>.camera.inputCamera;</span><br><span class="line">    [device lockForConfiguration:<span class="literal">nil</span>];</span><br><span class="line">    device.videoZoomFactor = videoScale;</span><br><span class="line">    [device unlockForConfiguration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)availableVideoScaleWithScale:(<span class="built_in">CGFloat</span>)scale &#123;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="keyword">self</span>.camera.inputCamera;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> maxScale = kMaxVideoScale;</span><br><span class="line">    <span class="built_in">CGFloat</span> minScale = kMinVideoScale;</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        maxScale = device.maxAvailableVideoZoomFactor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    scale = MAX(scale, minScale);</span><br><span class="line">    scale = MIN(scale, maxScale);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九、滤镜"><a href="#九、滤镜" class="headerlink" title="九、滤镜"></a>九、滤镜</h2><h3 id="1、滤镜的使用"><a href="#1、滤镜的使用" class="headerlink" title="1、滤镜的使用"></a>1、滤镜的使用</h3><p>当我们想使用一个滤镜的时候，只需要把它加到滤镜链里去，通过 <code>addTarget:</code> 方法实现。来看一下这个方法的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addTarget:(<span class="keyword">id</span>&lt;GPUImageInput&gt;)newTarget;</span><br></pre></td></tr></table></figure>
<p>可以看到，只要实现了 <code>GPUImageInput</code> 协议，就可以成为滤镜链的下一个结点。</p>
<h3 id="2、美颜滤镜"><a href="#2、美颜滤镜" class="headerlink" title="2、美颜滤镜"></a>2、美颜滤镜</h3><p>目前美颜效果已经成为相机应用的标配，我们也来给自己的相机加上美颜的效果。</p>
<p>美颜效果本质上是对图片做模糊，想要达到比较好的效果，需要结合人脸识别，只对人脸的部分进行模糊处理。这里并不去探究美颜算法的实现，直接找开源的美颜滤镜来用。</p>
<p>目前找到的实现效果比较好的是 <a href="https://github.com/LaiFengiOS/LFLiveKit/tree/master/LFLiveKit/filter" target="_blank" rel="noopener">LFGPUImageBeautyFilter</a> ，虽然它的效果肯定比不上现在市面上的美颜类 APP，但是作为学习级别的 Demo 已经足够了。</p>
<p>效果展示：</p>
<p><img src="https://raw.githubusercontent.com/lmf12/SimpleCam/master/Images/image-1.gif" alt=""></p>
<h3 id="3、自定义滤镜"><a href="#3、自定义滤镜" class="headerlink" title="3、自定义滤镜"></a>3、自定义滤镜</h3><p>打开 <code>GPUImageFilter</code> 的头文件，可以看到有下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithVertexShaderFromString:(<span class="built_in">NSString</span> *)vertexShaderString </span><br><span class="line">            fragmentShaderFromString:(<span class="built_in">NSString</span> *)fragmentShaderString;</span><br></pre></td></tr></table></figure>
<p>很容易理解，通过一个顶点着色器和一个片段着色器来初始化，并且可以看到是字符串类型。</p>
<p>另外，<code>GPUImageFilter</code> 中还内置了简单的顶点着色器和片段着色器，顶点着色器代码如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> kGPUImageVertexShaderString = SHADER_STRING</span><br><span class="line">(</span><br><span class="line"> attribute vec4 position;</span><br><span class="line"> attribute vec4 inputTextureCoordinate;</span><br><span class="line"> </span><br><span class="line"> varying vec2 textureCoordinate;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">void</span> main()</span><br><span class="line"> &#123;</span><br><span class="line">     gl_Position = position;</span><br><span class="line">     textureCoordinate = inputTextureCoordinate.xy;</span><br><span class="line"> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里用到了 <code>SHADER_STRING</code> 宏，看一下它的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define STRINGIZE(x) #x</span></span><br><span class="line"><span class="meta">#define STRINGIZE2(x) STRINGIZE(x)</span></span><br><span class="line"><span class="meta">#define SHADER_STRING(text) @ STRINGIZE2(text)</span></span><br></pre></td></tr></table></figure>
<p>在 <code>#define</code> 中的 <code>#</code> 是「字符串化」的意思，返回 C 语言风格字符串，而 <code>SHADER_STRING</code> 在字符串前面加了一个 <code>@</code> 符号，则 <code>SHADER_STRING</code> 的定义就是将括号中的内容转化为 OC 风格的字符串。</p>
<p>我们之前都是为着色器代码单独创建两个文件，而在 <code>GPUImageFilter</code> 中直接以字符串的形式，写死在代码中，两种方式本质上没什么区别。</p>
<p>当我们想自定义一个滤镜的时候，只需要继承 <code>GPUImageFilter</code> 来定义一个子类，然后用相同的方式来定义两个保存着色器代码的字符串，并且用这两个字符串来初始化子类就可以了。</p>
<p>作为示例，我把之前实现的 <a href="http://www.lymanli.com/2019/04/05/ios-opengles-filter/">抖音滤镜</a> 也添加到这个工程里，来看一下效果：</p>
<p><img src="https://raw.githubusercontent.com/lmf12/SimpleCam/master/Images/image-2.gif" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的步骤，我们实现了一个具备基础功能的相机。之后会在这个相机的基础上，继续做一些有趣的尝试，欢迎持续关注～</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>请到 <a href="https://github.com/lmf12/SimpleCam" target="_blank" rel="noopener">GitHub</a> 上查看完整代码。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><div class="note default"><p><a href="https://www.jianshu.com/p/690d83f9c052" target="_blank" rel="noopener">GPUImage（五）：五种类型输入源</a><br><a href="https://www.jianshu.com/p/8b4263d13cf0" target="_blank" rel="noopener">GPUImage源码阅读（六）</a><br><a href="https://www.jianshu.com/p/91044a81ec85" target="_blank" rel="noopener">GPUImage详细解析（九）图像的输入输出和滤镜通道</a><br><a href="https://objccn.io/issue-21-3/" target="_blank" rel="noopener">iOS 上的相机捕捉</a><br><a href="https://www.cnblogs.com/Anker/p/3418792.html" target="_blank" rel="noopener">C语言宏高级用法 [总结]</a><br><a href="http://www.saberismywife.com/2016/10/26/iOS%E7%BE%8E%E9%A2%9C%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">iOS美颜实现</a></p></div>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/09/ios-opengles-wobble/" rel="next" title="GLSL 与布丁晃动艺术">
                <i class="fa fa-chevron-left"></i> GLSL 与布丁晃动艺术
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/29/ios-gpuimage-face-detect/" rel="prev" title="在 GPUImage 中检测人脸关键点">
                在 GPUImage 中检测人脸关键点 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Lyman Li" />
            
              <p class="site-author-name" itemprop="name">Lyman Li</p>
              <p class="site-description motion-element" itemprop="description">来跳个舞吧</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/lmf12" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://juejin.im/user/5b141339f265da6e326c4883" target="_blank" title="掘金"><i class="fa fa-fw fa-wrench"></i>掘金</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.douban.com/people/lymanli" target="_blank" title="豆瓣"><i class="fa fa-fw fa-leaf"></i>豆瓣</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/e43d2bdec533" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i>简书</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#滤镜链简介"><span class="nav-text">滤镜链简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、滤镜链起点"><span class="nav-text">一、滤镜链起点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、滤镜"><span class="nav-text">二、滤镜</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、滤镜链终点"><span class="nav-text">三、滤镜链终点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#功能实现"><span class="nav-text">功能实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、拍照"><span class="nav-text">一、拍照</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、录制视频"><span class="nav-text">二、录制视频</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、单段录制"><span class="nav-text">1、单段录制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、多段录制"><span class="nav-text">2、多段录制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、保存"><span class="nav-text">三、保存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、保存图片"><span class="nav-text">1、保存图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、保存视频"><span class="nav-text">2、保存视频</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、闪光灯"><span class="nav-text">四、闪光灯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、画幅比例"><span class="nav-text">五、画幅比例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、前后置切换"><span class="nav-text">六、前后置切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、对焦"><span class="nav-text">七、对焦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、改变焦距"><span class="nav-text">八、改变焦距</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、滤镜"><span class="nav-text">九、滤镜</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、滤镜的使用"><span class="nav-text">1、滤镜的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、美颜滤镜"><span class="nav-text">2、美颜滤镜</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、自定义滤镜"><span class="nav-text">3、自定义滤镜</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码"><span class="nav-text">源码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>

  &nbsp;

  <span class="author" itemprop="copyrightHolder">Lyman Li</span>

  

  
</div>











        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("PCTCblrlpdJ41alrViDjBR2K-gzGzoHsz", "6Dxrsutiit9dF4bt71A80eUA");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  
  

  

  

  

  

</body>
</html>
