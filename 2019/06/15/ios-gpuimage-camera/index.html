<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="本文介绍了如何使用 GPUImage 来实现一个简单的相机。具体功能包括拍照、录制视频、多段视频合成、实时美颜、自定义滤镜实现等。 前言AVFoundation 是苹果提供的用于处理基于时间的媒体数据的一个框架。我们想要实现一个相机，需要从手机摄像头采集数据，离不开这个框架的支持。GPUImage 对 AVFoundation 做了一些封装，使我们的采集工作变得十分简单。 另外，GPUImage">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 GPUImage 实现一个简单相机">
<meta property="og:url" content="http://www.lymanli.com/2019/06/15/ios-gpuimage-camera/">
<meta property="og:site_name" content="Lyman&#39;s Blog">
<meta property="og:description" content="本文介绍了如何使用 GPUImage 来实现一个简单的相机。具体功能包括拍照、录制视频、多段视频合成、实时美颜、自定义滤镜实现等。 前言AVFoundation 是苹果提供的用于处理基于时间的媒体数据的一个框架。我们想要实现一个相机，需要从手机摄像头采集数据，离不开这个框架的支持。GPUImage 对 AVFoundation 做了一些封装，使我们的采集工作变得十分简单。 另外，GPUImage">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera.jpg">
<meta property="og:image" content="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera-image-1.jpg">
<meta property="og:image" content="https://media.githubusercontent.com/media/lmf12/ImageHost/master/SimpleCam/image-1.gif">
<meta property="og:image" content="https://media.githubusercontent.com/media/lmf12/ImageHost/master/SimpleCam/image-2.gif">
<meta property="article:published_time" content="2019-06-15T04:05:46.000Z">
<meta property="article:modified_time" content="2024-04-05T16:31:17.002Z">
<meta property="article:author" content="Lyman Li">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>使用 GPUImage 实现一个简单相机</title>
    <!-- async scripts -->
    <!-- Google Analytics -->




  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GZ8LZ0YJV8"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-GZ8LZ0YJV8');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     -->
      </ul>
    </span>
    <br/>
  <span id="menu">
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2019/09/29/ios-gpuimage-face-detect/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2019/05/09/ios-opengles-wobble/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
    </span>
    <br/>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%A4%E9%95%9C%E9%93%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">滤镜链简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%BB%A4%E9%95%9C%E9%93%BE%E8%B5%B7%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">一、滤镜链起点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%BB%A4%E9%95%9C"><span class="toc-number">2.2.</span> <span class="toc-text">二、滤镜</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%BB%A4%E9%95%9C%E9%93%BE%E7%BB%88%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">三、滤镜链终点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8B%8D%E7%85%A7"><span class="toc-number">3.1.</span> <span class="toc-text">一、拍照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91"><span class="toc-number">3.2.</span> <span class="toc-text">二、录制视频</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8D%95%E6%AE%B5%E5%BD%95%E5%88%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">1、单段录制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E6%AE%B5%E5%BD%95%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">2、多段录制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BF%9D%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">三、保存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87"><span class="toc-number">3.3.1.</span> <span class="toc-text">1、保存图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91"><span class="toc-number">3.3.2.</span> <span class="toc-text">2、保存视频</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%97%AA%E5%85%89%E7%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">四、闪光灯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%94%BB%E5%B9%85%E6%AF%94%E4%BE%8B"><span class="toc-number">3.5.</span> <span class="toc-text">五、画幅比例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%89%8D%E5%90%8E%E7%BD%AE%E5%88%87%E6%8D%A2"><span class="toc-number">3.6.</span> <span class="toc-text">六、前后置切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%AF%B9%E7%84%A6"><span class="toc-number">3.7.</span> <span class="toc-text">七、对焦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%94%B9%E5%8F%98%E7%84%A6%E8%B7%9D"><span class="toc-number">3.8.</span> <span class="toc-text">八、改变焦距</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%BB%A4%E9%95%9C"><span class="toc-number">3.9.</span> <span class="toc-text">九、滤镜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%BB%A4%E9%95%9C%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.9.1.</span> <span class="toc-text">1、滤镜的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BE%8E%E9%A2%9C%E6%BB%A4%E9%95%9C"><span class="toc-number">3.9.2.</span> <span class="toc-text">2、美颜滤镜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E9%95%9C"><span class="toc-number">3.9.3.</span> <span class="toc-text">3、自定义滤镜</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        使用 GPUImage 实现一个简单相机
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Lyman Li</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-06-15T04:05:46.000Z" class="dt-published" itemprop="datePublished">2019-06-15</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/GPUImage-%E5%AE%9E%E6%93%8D%E6%89%8B%E5%86%8C/">GPUImage 实操手册</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p><img src="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera.jpg"></p>
<p>本文介绍了如何使用 GPUImage 来实现一个简单的相机。具体功能包括拍照、录制视频、多段视频合成、实时美颜、自定义滤镜实现等。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>AVFoundation 是苹果提供的用于处理基于时间的媒体数据的一个框架。我们想要实现一个相机，需要从手机摄像头采集数据，离不开这个框架的支持。GPUImage 对 AVFoundation 做了一些封装，使我们的采集工作变得十分简单。</p>
<p>另外，GPUImage 的核心魅力还在于，它封装了一个链路结构的图像数据处理流程，简称<strong>滤镜链</strong>。滤镜链的结构使得多层滤镜的叠加功能变得很容易实现。</p>
<p>在下面介绍的功能中，有一些和 GPUImage 本身的关系并不大，我们是直接调用 AVFoundation 的 API 来实现的。但是，这些功能也是一个相机应用必不可少的一部分。所以，我们也会简单讲一下每个功能的实现方式和注意事项。</p>
<h1 id="滤镜链简介"><a href="#滤镜链简介" class="headerlink" title="滤镜链简介"></a>滤镜链简介</h1><p>在 GPUImage 中，对图像数据的处理都是通过建立滤镜链来实现的。</p>
<p>这里就涉及到了一个类 <code>GPUImageOutput</code> 和一个协议 <code>GPUImageInput</code> 。对于继承了 <code>GPUImageOutput</code> 的类，可以理解为<strong>具备输出图像数据</strong>的能力；对于实现了 <code>GPUImageInput</code> 协议的类，可以理解为<strong>具备接收图像数据输入</strong>的能力。</p>
<p>顾名思义，滤镜链作为一个链路，具有起点和终点。根据前面的描述，滤镜链的起点应该只继承了 <code>GPUImageOutput</code> 类，滤镜链的终点应该只实现了 <code>GPUImageInput</code> 协议，而对于中间的结点应该同时继承了 <code>GPUImageOutput</code> 类并实现了 <code>GPUImageInput</code> 协议，这样才具备承上启下的作用。</p>
<h2 id="一、滤镜链起点"><a href="#一、滤镜链起点" class="headerlink" title="一、滤镜链起点"></a>一、滤镜链起点</h2><p>在 GPUImage 中，只继承了 <code>GPUImageOutput</code>，而没有实现  <code>GPUImageInput</code> 协议的类有六个，也就是说有六种类型的输入源：</p>
<p><strong>1、GPUImagePicture</strong></p>
<p><code>GPUImagePicture</code> 通过图片来初始化，本质上是先将图片转化为 <code>CGImageRef</code>，然后将 <code>CGImageRef</code> 转化为纹理。</p>
<p><strong>2、GPUImageRawDataInput</strong></p>
<p><code>GPUImageRawDataInput</code> 通过二进制数据初始化，然后将二进制数据转化为纹理，在初始化的时候需要指明数据的格式（<code>GPUPixelFormat</code>）。</p>
<p><strong>3、GPUImageTextureInput</strong></p>
<p><code>GPUImageTextureInput</code> 通过已经存在的纹理来初始化。既然纹理已经存在，在初始化的时候就不会重新去生成，只是将纹理的索引保存下来。</p>
<p><strong>4、GPUImageUIElement</strong></p>
<p><code>GPUImageUIElement</code> 可以通过 <code>UIView</code> 或者 <code>CALayer</code> 来初始化，最后都是调用 <code>CALayer</code> 的 <code>renderInContext:</code> 方法，将当前显示的内容绘制到 CoreGraphics 的上下文中，从而获取图像数据。然后将数据转化为纹理。简单来说就是截屏，截取当前控件的内容。</p>
<p>这个类可以用来实现在视频上添加文字水印的功能。因为在 OpenGL 中不能直接进行文本的绘制，所以如果我们想把一个 <code>UILabel</code> 的内容添加到滤镜链里面去，使用 <code>GPUImageUIElement</code> 来实现是很合适的。</p>
<p><strong>5、GPUImageMovie</strong></p>
<p><code>GPUImageMovie</code> 通过本地的视频来初始化。首先通过 <code>AVAssetReader</code> 来逐帧读取视频，然后将帧数据转化为纹理，具体的流程大概是：<code>AVAssetReaderOutput</code> -&gt; <code>CMSampleBufferRef</code> -&gt; <code>CVImageBufferRef</code> -&gt; <code>CVOpenGLESTextureRef</code> -&gt; <code>Texture</code> 。 </p>
<p><strong>6、GPUImageVideoCamera</strong></p>
<p><code>GPUImageVideoCamera</code> 通过相机参数来初始化，通过<strong>屏幕比例</strong>和<strong>相机位置（前后置）</strong>来初始化相机。这里主要使用 <code>AVCaptureVideoDataOutput</code> 来获取持续的视频流数据输出，在代理方法 <code>captureOutput:didOutputSampleBuffer:fromConnection:</code> 中可以拿到 <code>CMSampleBufferRef</code> ，将其转化为纹理的过程与 <code>GPUImageMovie</code> 类似。</p>
<p>然而，我们在项目中使用的是它的子类 <code>GPUImageStillCamera</code>。 <code>GPUImageStillCamera</code> 在原来的基础上多了一个 <code>AVCaptureStillImageOutput</code>，它是我们实现拍照功能的关键，在 <code>captureStillImageAsynchronouslyFromConnection:completionHandler:</code> 方法的回调中，同样能拿到我们熟悉 <code>CMSampleBufferRef</code>。</p>
<p>简单来说，<code>GPUImageVideoCamera</code> 只能录制视频，<code>GPUImageStillCamera</code> 还可以拍照，因此我们使用 <code>GPUImageStillCamera</code> 。 </p>
<h2 id="二、滤镜"><a href="#二、滤镜" class="headerlink" title="二、滤镜"></a>二、滤镜</h2><p>滤镜链的关键角色是 <code>GPUImageFilter</code>，它同时继承了 <code>GPUImageOutput</code> 类并实现了 <code>GPUImageInput</code> 协议。<code>GPUImageFilter</code> 实现<strong>承上启下功能</strong>的基础是「渲染到纹理」，这个操作我们在 <a href="http://www.lymanli.com/2019/03/04/ios-opengles-spring/">《使用 iOS OpenGL ES 实现长腿功能》</a> 一文中已经介绍过了，简单来说就是<strong>将结果渲染到纹理而不是屏幕上</strong>。</p>
<p>这样，每一个滤镜都能把输出的纹理作为下一个滤镜的输入，实现多层滤镜效果的叠加。</p>
<h2 id="三、滤镜链终点"><a href="#三、滤镜链终点" class="headerlink" title="三、滤镜链终点"></a>三、滤镜链终点</h2><p>在 GPUImage 中，实现了 <code>GPUImageInput</code> 协议，而没有继承 <code>GPUImageOutput</code> 的类有四个：</p>
<p><strong>1、GPUImageMovieWriter</strong></p>
<p><code>GPUImageMovieWriter</code> 封装了 <code>AVAssetWriter</code>，可以逐帧从帧缓存的渲染结果中读取数据，最后通过 <code>AVAssetWriter</code> 将视频文件保存到指定的路径。</p>
<p><strong>2、GPUImageRawDataOutput</strong></p>
<p><code>GPUImageRawDataOutput</code> 通过 <code>rawBytesForImage</code> 属性，可以获取到当前输入纹理的二进制数据。</p>
<p>假设我们的滤镜链在输入源和终点之间，连接了三个滤镜，而我们需要拿到第二个滤镜渲染后的数据，用来做人脸识别。那我们可以在第二个滤镜后面再添加一个 <code>GPUImageRawDataOutput</code> 作为输出，则可以拿到对应的二进制数据，且不会影响原来的渲染流程。</p>
<p><strong>3、GPUImageTextureOutput</strong></p>
<p>这个类的实现十分简单，提供协议方法 <code>newFrameReadyFromTextureOutput:</code>，在每一帧渲染结束后，将自身返回，通过 <code>texture</code> 属性就可以拿到输入纹理的索引。</p>
<p><strong>4、GPUImageView</strong></p>
<p><code>GPUImageView</code> 继承自 <code>UIView</code>，通过输入的纹理，执行一遍渲染流程。这次的渲染目标不是新的纹理，而是自身的 <code>layer</code> 。</p>
<p>这个类是我们实现相机功能的重要组成部分，我们所有的滤镜效果，都要依靠它来呈现。</p>
<h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="一、拍照"><a href="#一、拍照" class="headerlink" title="一、拍照"></a>一、拍照</h2><p>拍照功能只需调用一个接口就能搞定，在回调方法中可以直接拿到 <code>UIImage</code>。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)takePhotoWtihCompletion:(TakePhotoResult)completion &#123;</span><br><span class="line">    GPUImageFilter *lastFilter = <span class="keyword">self</span>.currentFilterHandler.lastFilter;</span><br><span class="line">    [<span class="keyword">self</span>.camera capturePhotoAsImageProcessedUpToFilter:lastFilter withCompletionHandler:^(<span class="built_in">UIImage</span> *processedImage, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error &amp;&amp; completion) &#123;</span><br><span class="line">            completion(<span class="literal">nil</span>, error);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion(processedImage, <span class="literal">nil</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>值得注意的是，相机的预览页面由 <code>GPUImageView</code> 承载，显示的是整个滤镜链作用的结果。而我们的拍照接口，可以传入这个链路上的任意一个滤镜，甚至可以在后面多加一个滤镜，然后拍照接口会返回对应滤镜的渲染结果。即<strong>我们的拍照结果不一定要和我们的预览一致</strong>。</p>
<p>示意图如下：</p>
<p><img src="https://lymanli-1258009115.cos.ap-guangzhou.myqcloud.com/image/blog/gpuimage-camera-image-1.jpg"></p>
<h2 id="二、录制视频"><a href="#二、录制视频" class="headerlink" title="二、录制视频"></a>二、录制视频</h2><h3 id="1、单段录制"><a href="#1、单段录制" class="headerlink" title="1、单段录制"></a>1、单段录制</h3><p>录制视频首先要创建一个 <code>GPUImageMovieWriter</code> 作为链路的输出，与上面的拍照接口类似，这里录制的视频不一定和我们的预览一样。</p>
<p>整个过程比较简单，当我们调用停止录制的接口并回调之后，视频就被保存到我们指定的路径了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setupMovieWriter &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *videoPath = [SCFileHelper randomFilePathInTmpWithSuffix:<span class="string">@&quot;.m4v&quot;</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *videoURL = [<span class="built_in">NSURL</span> fileURLWithPath:videoPath];</span><br><span class="line">    <span class="built_in">CGSize</span> videoSize = <span class="keyword">self</span>.videoSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.movieWriter = [[GPUImageMovieWriter alloc] initWithMovieURL:videoURL</span><br><span class="line">                                                                size:videoSize];</span><br><span class="line">    </span><br><span class="line">    GPUImageFilter *lastFilter = <span class="keyword">self</span>.currentFilterHandler.lastFilter;</span><br><span class="line">    [lastFilter addTarget:<span class="keyword">self</span>.movieWriter];</span><br><span class="line">    <span class="keyword">self</span>.camera.audioEncodingTarget = <span class="keyword">self</span>.movieWriter;</span><br><span class="line">    <span class="keyword">self</span>.movieWriter.shouldPassthroughAudio = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.currentTmpVideoPath = videoPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)recordVideo &#123;</span><br><span class="line">    [<span class="keyword">self</span> setupMovieWriter];</span><br><span class="line">    [<span class="keyword">self</span>.movieWriter startRecording];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)stopRecordVideoWithCompletion:(RecordVideoResult)completion &#123;</span><br><span class="line">    @weakify(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span>.movieWriter finishRecordingWithCompletionHandler:^&#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        [<span class="keyword">self</span> removeMovieWriter];</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion(<span class="keyword">self</span>.currentTmpVideoPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、多段录制"><a href="#2、多段录制" class="headerlink" title="2、多段录制"></a>2、多段录制</h3><p>在 <code>GPUImage</code> 中并没有提供多段录制的功能，需要我们自己去实现。</p>
<p>首先，我们要重复单段视频的录制过程，这样我们就有了多段视频的文件路径。然后主要实现两个功能，一个是 <code>AVPlayer</code> 的多段视频循环播放；另一个是通过 <code>AVComposition</code> 来合并多段视频，并用 <code>AVAssetExportSession</code> 来导出新的视频。</p>
<p>整个过程逻辑并不复杂，出于篇幅的考虑，代码就不贴了，请到项目中查看。</p>
<h2 id="三、保存"><a href="#三、保存" class="headerlink" title="三、保存"></a>三、保存</h2><p>在拍照或者录视频结束后，通过 <code>PhotoKit</code> 保存到相册里。</p>
<h3 id="1、保存图片"><a href="#1、保存图片" class="headerlink" title="1、保存图片"></a>1、保存图片</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)writeImageToSavedPhotosAlbum:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                          completion:(<span class="type">void</span> (^)(<span class="type">BOOL</span> success))completion &#123;</span><br><span class="line">    [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123;</span><br><span class="line">        [PHAssetChangeRequest creationRequestForAssetFromImage:image];</span><br><span class="line">    &#125; completionHandler:^(<span class="type">BOOL</span> success, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion(success);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、保存视频"><a href="#2、保存视频" class="headerlink" title="2、保存视频"></a>2、保存视频</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)saveVideo:(<span class="built_in">NSString</span> *)path completion:(<span class="type">void</span> (^)(<span class="type">BOOL</span> success))completion &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:path];</span><br><span class="line">    [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123;</span><br><span class="line">        [PHAssetChangeRequest creationRequestForAssetFromVideoAtFileURL:url];</span><br><span class="line">    &#125; completionHandler:^(<span class="type">BOOL</span> success, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">                completion(success);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、闪光灯"><a href="#四、闪光灯" class="headerlink" title="四、闪光灯"></a>四、闪光灯</h2><p>系统的闪光灯类型通过 <code>AVCaptureDevice</code> 的 <code>flashMode</code> 属性来控制，其实只有三种，分别是：</p>
<ul>
<li><strong>AVCaptureFlashModeOff</strong> 关闭</li>
<li><strong>AVCaptureFlashModeOn</strong> 开启（在拍照的时候会闪一下）</li>
<li><strong>AVCaptureFlashModeAuto</strong> 自动（系统会自动判断当前的环境是否需要闪光灯）</li>
</ul>
<p>但是市面上的相机应用，一般还有一种<strong>常亮</strong>类型，这种类型在夜间的时候会比较适用。这个功能需要通过 <code>torchMode</code> 属性来实现，它其实是指手电筒。</p>
<p>我们对这个两个属性做一下封装，允许这四种类型来回切换，下面是根据封装的类型来同步系统类型的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)syncFlashState &#123;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="keyword">self</span>.camera.inputCamera;</span><br><span class="line">    <span class="keyword">if</span> (![device hasFlash] || <span class="keyword">self</span>.camera.cameraPosition == <span class="built_in">AVCaptureDevicePositionFront</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> closeFlashIfNeed];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [device lockForConfiguration:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.flashMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> SCCameraFlashModeOff:</span><br><span class="line">            device.torchMode = <span class="built_in">AVCaptureTorchModeOff</span>;</span><br><span class="line">            device.flashMode = <span class="built_in">AVCaptureFlashModeOff</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCCameraFlashModeOn:</span><br><span class="line">            device.torchMode = <span class="built_in">AVCaptureTorchModeOff</span>;</span><br><span class="line">            device.flashMode = <span class="built_in">AVCaptureFlashModeOn</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCCameraFlashModeAuto:</span><br><span class="line">            device.torchMode = <span class="built_in">AVCaptureTorchModeOff</span>;</span><br><span class="line">            device.flashMode = <span class="built_in">AVCaptureFlashModeAuto</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCCameraFlashModeTorch:</span><br><span class="line">            device.torchMode = <span class="built_in">AVCaptureTorchModeOn</span>;</span><br><span class="line">            device.flashMode = <span class="built_in">AVCaptureFlashModeOff</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [device unlockForConfiguration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、画幅比例"><a href="#五、画幅比例" class="headerlink" title="五、画幅比例"></a>五、画幅比例</h2><p>相机的比例通过设置 <code>AVCaptureSession</code> 的  <code>sessionPreset</code> 属性来实现。这个属性并不只意味着比例，也意味着分辨率。</p>
<p>由于不是所有的设备都支持高分辨率，所以这里只使用 <code>AVCaptureSessionPreset640x480</code> 和 <code>AVCaptureSessionPreset1280x720</code> 这两个分辨率，分别用来作为 <code>3:4</code> 和 <code>9:16</code> 的输出。</p>
<p>市面上的相机除了上面的两个比例外，一般还支持 <code>1:1</code> 和 <code>Full</code> （iPhoneX 系列的全屏）比例，但是系统并没有提供对应比例的 <code>AVCaptureSessionPreset</code> 。</p>
<p>这里可以通过 <code>GPUImageCropFilter</code> 来实现，这是 GPUImage 的一个内置滤镜，可以对输入的纹理进行裁剪。使用时通过 <code>cropRegion</code> 属性来传入一个归一化的裁剪区域。</p>
<p>切换比例的关键代码如下： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setRatio:(SCCameraRatio)ratio &#123;</span><br><span class="line">    _ratio = ratio;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ratio == SCCameraRatio1v1) &#123;</span><br><span class="line">        <span class="keyword">self</span>.camera.captureSessionPreset = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> space = (<span class="number">4</span> - <span class="number">3</span>) / <span class="number">4.0</span>; <span class="comment">// 竖直方向应该裁剪掉的空间</span></span><br><span class="line">        rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, space / <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> - space);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ratio == SCCameraRatio4v3) &#123;</span><br><span class="line">        <span class="keyword">self</span>.camera.captureSessionPreset = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ratio == SCCameraRatio16v9) &#123;</span><br><span class="line">        <span class="keyword">self</span>.camera.captureSessionPreset = <span class="built_in">AVCaptureSessionPreset1280x720</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ratio == SCCameraRatioFull) &#123;</span><br><span class="line">        <span class="keyword">self</span>.camera.captureSessionPreset = <span class="built_in">AVCaptureSessionPreset1280x720</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> currentRatio = SCREEN_HEIGHT / SCREEN_WIDTH;</span><br><span class="line">        <span class="keyword">if</span> (currentRatio &gt; <span class="number">16.0</span> / <span class="number">9.0</span>) &#123; <span class="comment">// 需要在水平方向裁剪</span></span><br><span class="line">            <span class="built_in">CGFloat</span> resultWidth = <span class="number">16.0</span> / currentRatio;</span><br><span class="line">            <span class="built_in">CGFloat</span> space = (<span class="number">9.0</span> - resultWidth) / <span class="number">9.0</span>;</span><br><span class="line">            rect = <span class="built_in">CGRectMake</span>(space / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> - space, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 需要在竖直方向裁剪</span></span><br><span class="line">            <span class="built_in">CGFloat</span> resultHeight = <span class="number">9.0</span> * currentRatio;</span><br><span class="line">            <span class="built_in">CGFloat</span> space = (<span class="number">16.0</span> - resultHeight) / <span class="number">16.0</span>;</span><br><span class="line">            rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, space / <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> - space);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.currentFilterHandler setCropRect:rect];</span><br><span class="line">    <span class="keyword">self</span>.videoSize = [<span class="keyword">self</span> videoSizeWithRatio:ratio];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、前后置切换"><a href="#六、前后置切换" class="headerlink" title="六、前后置切换"></a>六、前后置切换</h2><p>通过调用 <code>GPUImageVideoCamera</code> 的 <code>rotateCamera</code> 方法来实现。</p>
<p>另外，由于前置摄像头不支持闪光灯，如果在前置的时候去切换闪光灯，只能修改我们封装的类型。所以在切换到后置的时候，需要去同步一下系统的闪光灯类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)rotateCamera &#123;</span><br><span class="line">    [<span class="keyword">self</span>.camera rotateCamera];</span><br><span class="line">    <span class="comment">// 切换摄像头，同步一下闪光灯</span></span><br><span class="line">    [<span class="keyword">self</span> syncFlashState];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、对焦"><a href="#七、对焦" class="headerlink" title="七、对焦"></a>七、对焦</h2><p><code>AVCaptureDevice</code> 的 <code>focusMode</code> 用来设置聚焦模式，<code>focusPointOfInterest</code> 用来设置聚焦点；<code>exposureMode</code> 用来设置曝光模式，<code>exposurePointOfInterest</code> 用来设置曝光点。</p>
<p><strong>前置摄像头只支持设置曝光，后置摄像头支持设置曝光和聚焦</strong>，所以在设置之前要先判断是否支持。</p>
<p>需要注意的是，相机默认输出的图像是横向的，图像向右偏转。而前置摄像头又是镜像，所以图像是向左偏转。我们从 <code>UIView</code> 获得的触摸点，要经过相应的转化，才是正确的坐标。关键代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setFocusPoint:(<span class="built_in">CGPoint</span>)focusPoint &#123;</span><br><span class="line">    _focusPoint = focusPoint;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="keyword">self</span>.camera.inputCamera;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 坐标转换</span></span><br><span class="line">    <span class="built_in">CGPoint</span> currentPoint = <span class="built_in">CGPointMake</span>(focusPoint.y / <span class="keyword">self</span>.outputView.bounds.size.height, <span class="number">1</span> - focusPoint.x / <span class="keyword">self</span>.outputView.bounds.size.width);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.camera.cameraPosition == <span class="built_in">AVCaptureDevicePositionFront</span>) &#123;</span><br><span class="line">        currentPoint = <span class="built_in">CGPointMake</span>(currentPoint.x, <span class="number">1</span> - currentPoint.y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [device lockForConfiguration:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([device isFocusPointOfInterestSupported] &amp;&amp;</span><br><span class="line">        [device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeAutoFocus</span>]) &#123;</span><br><span class="line">        [device setFocusPointOfInterest:currentPoint];</span><br><span class="line">        [device setFocusMode:<span class="built_in">AVCaptureFocusModeAutoFocus</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([device isExposurePointOfInterestSupported] &amp;&amp;</span><br><span class="line">        [device isExposureModeSupported:<span class="built_in">AVCaptureExposureModeAutoExpose</span>]) &#123;</span><br><span class="line">        [device setExposurePointOfInterest:currentPoint];</span><br><span class="line">        [device setExposureMode:<span class="built_in">AVCaptureExposureModeAutoExpose</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    [device unlockForConfiguration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、改变焦距"><a href="#八、改变焦距" class="headerlink" title="八、改变焦距"></a>八、改变焦距</h2><p>改变焦距简单来说就是画面的放大缩小，通过设置 <code>AVCaptureDevice</code> 的 <code>videoZoomFactor</code> 属性实现。</p>
<p>值得注意的是，这个属性有最大值和最小值，设置之前需要做好判断，否则会直接崩溃。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setVideoScale:(<span class="built_in">CGFloat</span>)videoScale &#123;</span><br><span class="line">    _videoScale = videoScale;</span><br><span class="line">    </span><br><span class="line">    videoScale = [<span class="keyword">self</span> availableVideoScaleWithScale:videoScale];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="keyword">self</span>.camera.inputCamera;</span><br><span class="line">    [device lockForConfiguration:<span class="literal">nil</span>];</span><br><span class="line">    device.videoZoomFactor = videoScale;</span><br><span class="line">    [device unlockForConfiguration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)availableVideoScaleWithScale:(<span class="built_in">CGFloat</span>)scale &#123;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="keyword">self</span>.camera.inputCamera;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> maxScale = kMaxVideoScale;</span><br><span class="line">    <span class="built_in">CGFloat</span> minScale = kMinVideoScale;</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        maxScale = device.maxAvailableVideoZoomFactor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    scale = MAX(scale, minScale);</span><br><span class="line">    scale = MIN(scale, maxScale);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、滤镜"><a href="#九、滤镜" class="headerlink" title="九、滤镜"></a>九、滤镜</h2><h3 id="1、滤镜的使用"><a href="#1、滤镜的使用" class="headerlink" title="1、滤镜的使用"></a>1、滤镜的使用</h3><p>当我们想使用一个滤镜的时候，只需要把它加到滤镜链里去，通过 <code>addTarget:</code> 方法实现。来看一下这个方法的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)addTarget:(<span class="type">id</span>&lt;GPUImageInput&gt;)newTarget;</span><br></pre></td></tr></table></figure>

<p>可以看到，只要实现了 <code>GPUImageInput</code> 协议，就可以成为滤镜链的下一个结点。</p>
<h3 id="2、美颜滤镜"><a href="#2、美颜滤镜" class="headerlink" title="2、美颜滤镜"></a>2、美颜滤镜</h3><p>目前美颜效果已经成为相机应用的标配，我们也来给自己的相机加上美颜的效果。</p>
<p>美颜效果本质上是对图片做模糊，想要达到比较好的效果，需要结合人脸识别，只对人脸的部分进行模糊处理。这里并不去探究美颜算法的实现，直接找开源的美颜滤镜来用。</p>
<p>目前找到的实现效果比较好的是 <a target="_blank" rel="noopener" href="https://github.com/LaiFengiOS/LFLiveKit/tree/master/LFLiveKit/filter">LFGPUImageBeautyFilter</a> ，虽然它的效果肯定比不上现在市面上的美颜类 APP，但是作为学习级别的 Demo 已经足够了。</p>
<p>效果展示：</p>
<p><img src="https://media.githubusercontent.com/media/lmf12/ImageHost/master/SimpleCam/image-1.gif"></p>
<h3 id="3、自定义滤镜"><a href="#3、自定义滤镜" class="headerlink" title="3、自定义滤镜"></a>3、自定义滤镜</h3><p>打开 <code>GPUImageFilter</code> 的头文件，可以看到有下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)initWithVertexShaderFromString:(<span class="built_in">NSString</span> *)vertexShaderString </span><br><span class="line">            fragmentShaderFromString:(<span class="built_in">NSString</span> *)fragmentShaderString;</span><br></pre></td></tr></table></figure>

<p>很容易理解，通过一个顶点着色器和一个片段着色器来初始化，并且可以看到是字符串类型。</p>
<p>另外，<code>GPUImageFilter</code> 中还内置了简单的顶点着色器和片段着色器，顶点着色器代码如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> kGPUImageVertexShaderString = SHADER_STRING</span><br><span class="line">(</span><br><span class="line"> attribute vec4 position;</span><br><span class="line"> attribute vec4 inputTextureCoordinate;</span><br><span class="line"> </span><br><span class="line"> varying vec2 textureCoordinate;</span><br><span class="line"> </span><br><span class="line"> <span class="type">void</span> main()</span><br><span class="line"> &#123;</span><br><span class="line">     gl_Position = position;</span><br><span class="line">     textureCoordinate = inputTextureCoordinate.xy;</span><br><span class="line"> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里用到了 <code>SHADER_STRING</code> 宏，看一下它的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGIZE(x) #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGIZE2(x) STRINGIZE(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_STRING(text) @ STRINGIZE2(text)</span></span><br></pre></td></tr></table></figure>

<p>在 <code>#define</code> 中的 <code>#</code> 是「字符串化」的意思，返回 C 语言风格字符串，而 <code>SHADER_STRING</code> 在字符串前面加了一个 <code>@</code> 符号，则 <code>SHADER_STRING</code> 的定义就是将括号中的内容转化为 OC 风格的字符串。</p>
<p>我们之前都是为着色器代码单独创建两个文件，而在 <code>GPUImageFilter</code> 中直接以字符串的形式，写死在代码中，两种方式本质上没什么区别。</p>
<p>当我们想自定义一个滤镜的时候，只需要继承 <code>GPUImageFilter</code> 来定义一个子类，然后用相同的方式来定义两个保存着色器代码的字符串，并且用这两个字符串来初始化子类就可以了。</p>
<p>作为示例，我把之前实现的 <a href="http://www.lymanli.com/2019/04/05/ios-opengles-filter/">抖音滤镜</a> 也添加到这个工程里，来看一下效果：</p>
<p><img src="https://media.githubusercontent.com/media/lmf12/ImageHost/master/SimpleCam/image-2.gif"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的步骤，我们实现了一个具备基础功能的相机。之后会在这个相机的基础上，继续做一些有趣的尝试，欢迎持续关注～</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>请到 <a target="_blank" rel="noopener" href="https://github.com/lmf12/SimpleCam">GitHub</a> 上查看完整代码。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/690d83f9c052">GPUImage（五）：五种类型输入源</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8b4263d13cf0">GPUImage源码阅读（六）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/91044a81ec85">GPUImage详细解析（九）图像的输入输出和滤镜通道</a></li>
<li><a target="_blank" rel="noopener" href="https://objccn.io/issue-21-3/">iOS 上的相机捕捉</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3418792.html">C语言宏高级用法 [总结]</a></li>
<li><a target="_blank" rel="noopener" href="http://www.saberismywife.com/2016/10/26/iOS%E7%BE%8E%E9%A2%9C%E5%AE%9E%E7%8E%B0/">iOS美颜实现</a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/about/">关于</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%A4%E9%95%9C%E9%93%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">滤镜链简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%BB%A4%E9%95%9C%E9%93%BE%E8%B5%B7%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">一、滤镜链起点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%BB%A4%E9%95%9C"><span class="toc-number">2.2.</span> <span class="toc-text">二、滤镜</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%BB%A4%E9%95%9C%E9%93%BE%E7%BB%88%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">三、滤镜链终点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8B%8D%E7%85%A7"><span class="toc-number">3.1.</span> <span class="toc-text">一、拍照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91"><span class="toc-number">3.2.</span> <span class="toc-text">二、录制视频</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8D%95%E6%AE%B5%E5%BD%95%E5%88%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">1、单段录制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E6%AE%B5%E5%BD%95%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">2、多段录制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BF%9D%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">三、保存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87"><span class="toc-number">3.3.1.</span> <span class="toc-text">1、保存图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91"><span class="toc-number">3.3.2.</span> <span class="toc-text">2、保存视频</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%97%AA%E5%85%89%E7%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">四、闪光灯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%94%BB%E5%B9%85%E6%AF%94%E4%BE%8B"><span class="toc-number">3.5.</span> <span class="toc-text">五、画幅比例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%89%8D%E5%90%8E%E7%BD%AE%E5%88%87%E6%8D%A2"><span class="toc-number">3.6.</span> <span class="toc-text">六、前后置切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%AF%B9%E7%84%A6"><span class="toc-number">3.7.</span> <span class="toc-text">七、对焦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%94%B9%E5%8F%98%E7%84%A6%E8%B7%9D"><span class="toc-number">3.8.</span> <span class="toc-text">八、改变焦距</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%BB%A4%E9%95%9C"><span class="toc-number">3.9.</span> <span class="toc-text">九、滤镜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%BB%A4%E9%95%9C%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.9.1.</span> <span class="toc-text">1、滤镜的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BE%8E%E9%A2%9C%E6%BB%A4%E9%95%9C"><span class="toc-number">3.9.2.</span> <span class="toc-text">2、美颜滤镜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E9%95%9C"><span class="toc-number">3.9.3.</span> <span class="toc-text">3、自定义滤镜</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol>
      </div>
    

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    Lyman Li
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
